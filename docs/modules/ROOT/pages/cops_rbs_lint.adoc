////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= RBS/Lint

[#rbslintambiguouskeywordargumentkey]
== RBS/Lint/AmbiguousKeywordArgumentKey

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| -
| -
|===

Checks keyword argument keys that are not local variable names.

[#examples-rbslintambiguouskeywordargumentkey]
=== Examples

[#default-rbslintambiguouskeywordargumentkey]
==== default

[source,rbs]
----
# bad
def foo: (option?: bool, option!: bool, Option: bool) -> void
----

[#rbslintambiguousoperatorprecedence]
== RBS/Lint/AmbiguousOperatorPrecedence

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| -
| -
|===

Checks for ambiguity of Union and Intersection operators.

[#examples-rbslintambiguousoperatorprecedence]
=== Examples

[#default-rbslintambiguousoperatorprecedence]
==== default

[source,rbs]
----
# bad
def foo: (A | B & C) -> void

# good
def foo: (A | (B & C)) -> void
----

[#rbslintduplicateannotation]
== RBS/Lint/DuplicateAnnotation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Checks that there are no repeated annotations.

[#examples-rbslintduplicateannotation]
=== Examples

[source,rbs]
----
# bad
def %a{foo} %a{foo} def foo: () -> void

# bad
def %a{foo} foo: %a{foo} () -> void

# bad
def foo: %a{foo} %a{foo} () -> void

# not bad
def foo: %a{foo} () -> void
       | %a{foo} (Integer) -> void
----

[#rbslintduplicateoverload]
== RBS/Lint/DuplicateOverload

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Checks that there are no repeated overload bodies.
This cop ignores the difference of return type.

[#examples-rbslintduplicateoverload]
=== Examples

[source,rbs]
----
# bad
def foo: () -> void
       | () -> top
----

[#rbslintimplicitlyreturnsnil]
== RBS/Lint/ImplicitlyReturnsNil

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| -
| -
|===

This cop checks for conflicts between `implicitly-returns-nil` annotations and return types.

[#examples-rbslintimplicitlyreturnsnil]
=== Examples

[source,rbs]
----
# bad
%a{implicitly-returns-nil}
def foo: () -> Integer?

# good
%a{implicitly-returns-nil}
def foo: () -> Integer

# good
def foo: () -> Integer?
----

[#rbslintliteralintersection]
== RBS/Lint/LiteralIntersection

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Checks that there are no repeated overload bodies

[#examples-rbslintliteralintersection]
=== Examples

[#default-rbslintliteralintersection]
==== default

[source,rbs]
----
# bad
1 & 2

# bad
1 & _Foo
----

[#rbslintnewreturnsvoid]
== RBS/Lint/NewReturnsVoid

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Checks that there are void types in the return type of `.new` method
`self.new` is a special and fundamental method, and extra care should be taken regarding its return value.
In most cases, assigning it `void` is an unintended mistake.

[#examples-rbslintnewreturnsvoid]
=== Examples

[source,rbs]
----
# bad
def self.new: () -> void

# good
def self.new: () -> instance
----

[#rbslintrestkeywordhash]
== RBS/Lint/RestKeywordHash

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Specifying the `Hash` type for `**` is a very special case and,
in most situations, it is a mistake in type specification.

[#examples-rbslintrestkeywordhash]
=== Examples

[source,rbs]
----
# bad
def foo: (**Hash[Symbol, String]) -> void
# e.g.) foo(a: {x: "x"}, b: {y: "y"}, c: {z: "z"})

# good
def foo: (**String) -> void
# e.g.) foo(a: "x", b: "y", c: "z")
----

[#rbslintsyntax]
== RBS/Lint/Syntax

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Just only for syntax error

[#rbslinttoplevelinterface]
== RBS/Lint/TopLevelInterface

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Top-level namespaces are likely to conflict and should be avoided.

[#examples-rbslinttoplevelinterface]
=== Examples

[source,rbs]
----
# bad
interface _Option
  def option: () -> untyped
end

# good
class Foo
  interface _Option
    def option: () -> untyped
  end
end
----

[#rbslinttopleveltypealias]
== RBS/Lint/TopLevelTypeAlias

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Top-level namespaces are likely to conflict and should be avoided.

[#examples-rbslinttopleveltypealias]
=== Examples

[source,rbs]
----
# bad
type foo = String

# good
class Foo
  type bar = Integer
end
----

[#rbslintunusedoverloadtypeparams]
== RBS/Lint/UnusedOverloadTypeParams

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Notice unused overload type parameters.

[#examples-rbslintunusedoverloadtypeparams]
=== Examples

[source,rbs]
----
# bad
def foo: [T] () -> void

# good
def foo: [T] (T) -> T
----

[#rbslintunusedtypealiastypeparams]
== RBS/Lint/UnusedTypeAliasTypeParams

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Notice unused type parameters.

[#examples-rbslintunusedtypealiastypeparams]
=== Examples

[source,rbs]
----
# bad
type ary[T] = Array[Integer]

# good
type ary[T] = Array[T]
----

[#rbslintuselessaccessmodifier]
== RBS/Lint/UselessAccessModifier

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| -
| -
|===

Checks for redundant access modifiers in class and module definitions.

[#examples-rbslintuselessaccessmodifier]
=== Examples

[source,rbs]
----
# bad
class Foo
  public # this is redundant (default access is public)

  def method: () -> void
end

# bad
class Foo
  # The following is redundant (methods defined on the class'
  # singleton class are not affected by the private modifier)
  private

  def self.method3: () -> void
end

# bad
class Foo
  private # this is redundant (no following methods are defined)
end

# good
class Foo
  private # this is not redundant (a method is defined)

  def method2
  end
end
----

[#rbslintwillsyntaxerror]
== RBS/Lint/WillSyntaxError

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

This cop checks the WillSyntaxError in RBS.
RBS with this diagnostics will fail in `rbs validate` command.

[#examples-rbslintwillsyntaxerror]
=== Examples

[source,rbs]
----
# bad
def foo: (void) -> void

# bad
CONST: self
----
